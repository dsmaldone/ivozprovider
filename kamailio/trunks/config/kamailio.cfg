#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define SIP_PORT 5060
#!define SIPS_PORT 5061
#!define XMLRPC_PORT 8001

# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# ACC Flags
#!define FLT_ACC 1
#!define FLT_ACCFAILED 2

# DLG_FLAG
#!define DLG_FLAG 3

# - options
#!define WITH_ANTIFLOOD

#!define DELAY_MEDIALIBERATION
# Note: If defined, Kamailio delays Asterisk initial media liberation for 1 second (only on outbound calls)

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

####### Global Parameters #########

listen=udp:IP:SIP_PORT
listen=tcp:IP:SIP_PORT
listen=tls:IP:SIPS_PORT
listen=tcp:IP:XMLRPC_PORT

# -- Debug level
# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# If debug level of message is lower than current debug parameter, it gets printed
# Current value: 2 (INFO and higher)
#
# This setting can me modified/seen live running:
# kamcmd-proxyusers cfg.seti core debug X
# kamcmd-proxyusers cfg.get core debug

debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes
version_table="kam_version"

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec Ivoz Provider v1.0"
user_agent_header="User-Agent: Irontec Ivoz Provider v1.0"

####### Runtime cfg values (kamcmd cfg.list) #########

# Log dialogs initiated by these SIP methods
dolog.invite    = 1 desc "If 1, log invite transactions"
dolog.register  = 1 desc "If 1, log register transactions"
dolog.publish   = 1 desc "If 1, log publish transactions"
dolog.subscribe = 1 desc "If 1, log subscribe transactions"
dolog.notify    = 1 desc "If 1, log notify transactions"
dolog.options   = 1 desc "If 1, log options transactions"
dolog.message   = 1 desc "If 1, log message transactions"
dolog.refer     = 1 desc "If 1, log refer transactions"

# Debug
dolog.xmlrpc    = 0 desc "If 1, debug XMLRPC"
dolog.printmsg_methods = 'NONE' desc "Print full SIP messages with these methods" # e.g. 'INVITE|REGISTER', 'NONE' to disable

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "mi_fifo.so"
loadmodule    "mi_rpc.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "sqlops.so"
loadmodule    "rtpproxy.so"
loadmodule    "cfg_rpc.so"
loadmodule    "dialog.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "acc.so"
loadmodule    "lcr.so"
loadmodule    "uac.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "xhttp.so"
loadmodule    "domain.so"
loadmodule    "cfgutils.so"
loadmodule    "dialplan.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "permissions.so"
loadmodule    "diversion.so"
loadmodule    "ipops.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_DSSOCKET)")
modparam("dispatcher", "attrs_avp", "$avp(DSATTRS)")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 2)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@trunks.ivozprovider.local")
modparam("dispatcher", "hash_pvar", "$avp(hash)")

# TLS
modparam("tls", "config", "/etc/kamailio/proxytrunks/tls.cfg")
modparam("tls", "tls_log", 1)

# MI_FIFO
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_proxytrunks_fifo")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxytrunks_ctl")

# RTPPROXY
modparam("rtpproxy", "db_url", DBURL)
modparam("rtpproxy", "table_name", "kam_rtpproxy")
modparam("rtpproxy", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpproxy", "nortpproxy_str", "a=sdpmangled:yes\r\n")

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# ACC
# -- transactions to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "acc_time_column", "localtime")
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- cdr accounting to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 0)
modparam("acc", "cdrs_table", "kam_acc_cdrs")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "proxy=$dlg_var(proxy);brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);peeringContractId=$dlg_var(peeringContractId);referrer=$dlg_var(referrer);referee=$dlg_var(referee);direction=$dlg_var(direction);bounced=$dlg_var(bounced)")

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "activeCallsCompany; activeCallsBrand")
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n") # Added to requests generated locally by the module (e.g. BYE)
modparam("dialog", "track_cseq_updates", 1)

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif

# UAC
modparam("uac", "auth_realm_avp","$avp(realm)")
modparam("uac", "auth_username_avp","$avp(provideruser)")
modparam("uac", "auth_password_avp","$avp(secret)")
modparam("uac", "restore_mode","auto")
modparam("uac", "restore_dlg", 1)
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_db_table", "kam_trunks_uacreg")
modparam("uac", "reg_contact_addr", "reg_contact_addr")
modparam("uac", "reg_timer_interval", 60)
modparam("uac", "reg_retry_interval", 300)

# LCR
modparam("lcr", "db_url", DBURL)
modparam("lcr", "lcr_gw_table","LcrGateways")
modparam("lcr", "lcr_rule_table", "LcrRules")
modparam("lcr", "lcr_rule_target_table", "LcrRuleTargets")
modparam("lcr", "gw_name_column", "gw_name")
modparam("lcr", "ip_addr_column", "ip")
modparam("lcr", "lcr_id_column", "lcr_id")
modparam("lcr", "gw_uri_avp", "$avp(gw_uri_avp)")
modparam("lcr", "ruri_user_avp", "$avp(i:500)")
modparam("lcr", "tag_avp", "$avp(lcr_tag)")
modparam("lcr", "flags_avp", "$avp(s:caller_method)")
modparam("lcr", "defunct_capability", 1)
modparam("lcr", "lcr_id_avp", "$avp(lcr_id_avp)")
modparam("lcr", "defunct_gw_avp", "$avp(defunct_gw_avp)")
modparam("lcr", "lcr_rule_hash_size", 1024)
modparam("lcr", "lcr_gw_count", 1024)
modparam("lcr", "fetch_rows", 3000)
modparam("lcr", "ping_interval", 15) # Ping every 15 seconds
modparam("lcr", "ping_inactivate_threshold", 1) # Mark as inactive at first call of inactivate_gw()
modparam("lcr", "ping_valid_reply_codes", "403,404,405,501") # Mark as active when 2XX or these reply codes
modparam("lcr", "ping_from", "sip:pinger@localhost")
modparam("lcr", "lcr_count", 1)
modparam("lcr", "dont_strip_or_prefix_flag", 1)

# TM
modparam("tm", "fr_timer", 5000)
modparam("tm", "retr_timer1", 500)

# SANITY
modparam("sanity", "autodrop", 0)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_trunks_domain")
modparam("domain", "domain_attrs_table", "kam_trunks_domain_attrs")
modparam("domain", "register_myself", 1)

# DIALPLAN
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "table_name", "kam_trunks_dialplan")
modparam("dialplan", "attrs_pvar", "$avp(s:appliedrule)")

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_trunks_address") # Not used
modparam("permissions", "trusted_table", "kam_pike_trusted") # IPs excluded from pike checking
modparam("permissions", "db_mode", 1)

####### Routing Logic ########

request_route {
    # per request initial checks
    route(REQINIT);

    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($si:$sp) [$proto]\n");

    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) xlog("L_WARN", "Received message:\n\n$mb\n");

    if (is_method("OPTIONS")) {
        force_rport();
        send_reply("200", "I'm here!");
        exit;
    }

    route(ANTIFLOOD);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si\n");
        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RELAY);
        }

        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # Manage retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        route(WITHINDLG);
    }

    ### only initial requests (no To tag)

    # Only INVITE can start a dialog
    if (!is_method("INVITE")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Remove preloaded route headers
    remove_hf("Route");

    # Manage dialog
    dlg_manage();

    # Reconfigure XLOG for second calls to dlg_manage (dlg_vars are lost). Currently only after 422.
    route(CONFIGURE_XLOG);

    # Setup accounting
    route(ACCOUNTING);

    # Add record-route to INVITE requests
    record_route();

    # Is a call bounced previously to AS?
    $var(header) = 'X-Info-Bounced';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) == 'yes') {
        $dlg_var(bounced) = 'yes';
    } else {
        $dlg_var(bounced) = 'no';
    }


    # Easy routing:
    # (a) From ASs ----> Choose GW (except bounced calls)
    # (b) To my domains ----> Dispatch to AS
    if (ds_is_from_list("1") && $dlg_var(bounced) == 'no') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AS calling, route to corresponding GW\n");
        $dlg_var(direction) = 'outbound';

        # AS provides needed info in X-INFO header
        route(PARSE_X_HEADERS);

        # Control maxcalls
        route(CONTROL_MAXCALLS);

        # Save internal Contact to prevent misrouting
        route(SAVE_CONTACT);

        #!ifdef DELAY_MEDIALIBERATION
        $dlg_var(initial_reinvite) = 'pending';
        #!endif

        # Evaluate routing logic
        route(LOAD_GWS);

        # -- is our DDI??
        $var(header) = 'X-Info-BounceMe';
        route(PARSE_OPTIONAL_X_HEADER);
        if ($var(header-value) == 'yes') {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] This is our DDI, forward to AS for new CID\n");
            insert_hf("X-Info-BounceDDI: $rU\r\n");
            $avp(distributeMethod) = 'static'; # Bounce to same AS
            $avp(asAddress) = $si; # Bounce to same AS
            $rU = 'bounce';
            route(DISPATCH);
            $dlg_var(peeringContractId) = $avp(peeringContractId);
            $dlg_var(bounced) = 'yes';
        }

        route(RELAY);
    } else {
        if (uri==myself) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Someone calling to my domain, dispatch to AS\n");
            $dlg_var(direction) = 'inbound';

            # X-HEADERS are for internal use only, they shouldn't be added by trunks
            remove_hf_re("^X-");

            route(TRANSFORMATE_IN);
            route(GET_INFO_FROM_MATCHED_DDI);
            route(CONTROL_MAXCALLS);

            route(DISPATCH);
            route(RELAY);
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rd is not one of my domains, 404 Not Here\n");
            send_reply("404", "Not Here");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Main script error, should NOT arrive this point.\n");
    drop;
}

route[REQINIT] {
    # Easy dropping for scanners
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent" || search("sipvicious")) {
        xlog("L_WARN", "REQINIT: Dropping scanner request ----> $rm from $si\n");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        xlog("L_ERR", "REQINIT: Dropping malformed SIP message from $si:$sp\n");
        exit;
    }

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        xlog("L_ERR", "REQINIT: Too many hops for SIP message from $si:$sp\n");
        send_reply("483","Too Many Hops");
        exit;
    }
}

route[LOAD_GWS] {
    $var(filter) = 'b' + $dlg_var(brandId) + 'c' + $dlg_var(companyId);
    if ($avp(fax)) {
        load_gws(1, 'fax', $var(filter));
        if ($avp(gw_uri_avp) != $null) {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOAD-GWS: Fax specific route found\n");
        }
    }

    if ($avp(gw_uri_avp) == $null) {
        load_gws(1, $rU, $var(filter));
    }

    if ($avp(gw_uri_avp) != $null) {
        # At least one gateway loaded, continue

        # Store original ru value to reuse in SELECT-GW invocations
        $dlg_var(ru_before_lcr) = $ru;

        route(SELECT_GW);
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOAD-GWS: No valid gateway for '$rU' for company '$dlg_var(companyId)'\n");
        send_reply("500", "Server Internal Error - No gateways");
        exit;
    }

    t_on_failure("MANAGE_FAILURE_GW");
    t_on_branch("MANAGE_BRANCH_GW");
}

route[SELECT_GW] {
    $ru = $dlg_var(ru_before_lcr); # Restore initial value for subsequent calls
    $du = $null;

    # Evaluate gateway rules
    if (!next_gw()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: NO next GW, send 503 No gateways");
        send_reply("503", "No gateways");
        exit;
    }

    # GW selection may modify both $ru and $du
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: New dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: New RURI $ru\n");

    # Store du and ru after choosing GW to reuse in case of 401|407 (to preserve gw prefix and suffix)
    $avp(du_after_lcr) = $du;
    $avp(ru_after_lcr) = $ru;

    # Skip GW if has an unresolvable domain
    if(!is_ip("$nh(d)")) {
        if (!dns_query("$nh(d)", "nextgwaddr")) {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Not resolvable domain '$nh(d)', skip GW");
            route(SELECT_GW);
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Resolvable domain '$nh(d)' ($dns(nextgwaddr=>addr)) in GW, proceed");
        }
    }

    # Obtain info about selected GW
    sql_xquery("cb", "SELECT auth_needed, auth_user, auth_password, peeringContractId, from_user, from_domain, prefix FROM PeerServers WHERE id=$avp(lcr_tag)", "ra");

    if ( $(xavp(ra=>peeringContractId){s.len}) ) {
        $avp(peeringContractId) = $xavp(ra=>peeringContractId);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: peeringContractId: $avp(peeringContractId)\n");
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Error obtaining 'peeringContractId' for peerServerId '$avp(lcr_tag)'\n");
        send_reply("500", "Server Internal Error");
        exit;
    }

    if ($xavp(ra=>auth_needed) == 'yes') {
        if ( $(xavp(ra=>auth_user){s.len}) ) {
            $avp(provideruser) = $xavp(ra=>auth_user);
        } else {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Error obtaining 'provideruser' for peerServerId '$avp(lcr_tag)'\n");
        }

        if ( $(xavp(ra=>auth_password){s.len}) ) {
            $avp(secret) = $xavp(ra=>auth_password);
        } else {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SELECT-GW: Error obtaining 'secret' for peerServerId '$avp(lcr_tag)'\n");
        }
    } else {
        $avp(provideruser) = $null;
        $avp(secret) = $null;
    }

    if ( $(xavp(ra=>from_user){s.len}) ) {
        $avp(from_user) = $xavp(ra=>from_user);
    } else {
        $avp(from_user) = $null;
    }

    if ( $(xavp(ra=>from_domain){s.len}) ) {
        $avp(from_domain) = $xavp(ra=>from_domain);
    } else {
        $avp(from_domain) = $null;
    }

    if ( $(xavp(ra=>prefix){s.len}) ) {
        $avp(gw_prefix) = $xavp(ra=>prefix);
    } else {
        $avp(gw_prefix) = $null;
    }

    # Reset auth flag
    $avp(auth_done) = '0';
}

route[PARSE_X_HEADERS] {
    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(xcallid) = $var(header-value);

    # -- xcallid is mandatory for every normal call.
    #    Check if X-Info-Special header is present with 'fax' value (current only exception)
    if ($(dlg_var(xcallid){s.len}) == 0) {
        $var(header) = 'X-Info-Special';
        route(PARSE_OPTIONAL_X_HEADER);
        if ($var(header-value) == 'fax') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-X-HEADERS: Special case without xcallid: fax\n");
            $avp(fax) = '1';
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-X-HEADERS: Invalid $var(header) value ($var(header-value)) for call without xcallid\n");
            send_reply("500", "x-callid is missing");
            exit;
        }
    } else {
        if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Related leg: $dlg_var(xcallid)\n");
    }

    # Extract brandId
    $var(header) = 'X-Info-BrandId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(brandId) = $var(header-value);

    # Extract brandMaxcalls
    $var(header) = 'X-Info-BrandMaxCalls';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(maxCallsBrand) = $var(header-value);

    # Extract companyId
    $var(header) = 'X-Info-CompanyId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyId) = $var(header-value);

    # Extract companyName
    $var(header) = 'X-Info-CompanyName';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyName) = $var(header-value);

    # Extract companyDomain
    $var(header) = 'X-Info-CompanyDomain';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyDomain) = $var(header-value);

    # Extract companyMaxcalls
    $var(header) = 'X-Info-CompanyMaxCalls';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(maxCallsCompany) = $var(header-value);

    # Extract MediaRelaySet (can be null and non-exist)
    $var(header) = 'X-Info-MediaRelaySet';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(mediaRelaySetsId) = $var(header-value);

    # Extract Record header
    $var(header) = 'X-Info-Record';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) == 'yes') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-X-HEADERS: '$var(header)' header found, call will be recorded\n");
        $avp(recordCall) = 'yes';
    }
}

# Header might not be present and, if present, might be empty
route[PARSE_OPTIONAL_X_HEADER] {
    if (is_present_hf($var(header))) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        $var(header-value) = '';
    }
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[TRANSFORMATE_IN] {
    if ($dlg_var(bounced) == 'yes') {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: Skipping transformations for bounced calls, AS talk E.164\n");
        return;
    }

    # Get all DDI candidates
    sql_query("cb", "SELECT d.DDIE164, t.callee_in, t.caller_in, p.brandId from DDIs AS d INNER JOIN PeeringContracts AS p ON d.peeringContractId = p.id LEFT JOIN TransformationRulesetGroupsTrunks t ON t.id=p.transformationRulesetGroupsTrunksId  WHERE '$rU' REGEXP CONCAT('[0-9]*', DDI) ORDER BY LENGTH(DDIE164) DESC", "ra");

    # Are there any candidates?
    if ($dbr(ra=>rows) == 0) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: $rU not recognized in any company, 404 Not Found\n");
        send_reply("404", "Not Here");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: There are $dbr(ra=>rows) DDI candidates, proceed\n");
    }

    # Evaluate all candidates ($rU after transformation must be equal to candidate, otherwise it is rejected)
    $var(i) = 0;
    while ($var(i)<$dbr(ra=>rows)) {
        $var(candidate) = $dbr(ra=>[$var(i), 0]);
        $var(transformation) = $dbr(ra=>[$var(i), 1]);
        $dlg_var(brandId) = $dbr(ra=>[$var(i), 3]); # If not set in CONFIGURE_XLOG, brandId is set here
        $var(number) = $rU;
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        if ($var(transformated) == $var(candidate)) {
            # We have a winner candidate!!
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: Callee $rU is recognized as $var(candidate) (should be E164)\n");
            $rU = $var(candidate);
            $dlg_var(callee) = $rU;

            # Transformate caller with corresponding transformation
            route(GET_CALLER); # Greps caller and sets it in $var(caller)
            $var(transformation) = $dbr(ra=>[$var(i), 2]);
            $var(number) = $var(caller);
            route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
            $var(caller) = $var(transformated);
            route(SET_CALLER); # Sets caller using $var(caller) value
            $dlg_var(caller) = $var(caller);

            # Free and leave
            sql_result_free("ra");
            return;
        }
        $var(i) = $var(i) + 1;
    }
    sql_result_free("ra");

    # No candidate succeeded after applying transformations
    if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-IN: No DDI candidate succeeded after applying transformations to $rU, 404 Not Found");
    send_reply("404", "Not Here");
    exit;
}

# Sets caller in $var(caller) seeking in PAI/RPID/From (in this order)
route[GET_CALLER] {
    # Where is my caller? PAI/RPID/From?
    if (is_present_hf("P-Asserted-Identity")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-CALLER: PAI present: $(ai{uri.user})\n");
        $var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-CALLER: RPID present: $(re{uri.user})\n");
        $var(caller) = $(re{uri.user});
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-CALLER: Nor PAI nor RPID present, only From ($fU)! :(\n");
        $var(caller) = $fU;
    }
}

# Sets caller in PAI/RPID/From using $var(caller) value
route[SET_CALLER] {
    # Set final caller in corresponding header
    if (is_present_hf("P-Asserted-Identity")) {
        remove_hf("Remote-Party-ID"); # If PAI present, RPID out
        if ($(ai{uri.user}) != $var(caller)) { # If new value differs from previous, change
            remove_hf("P-Asserted-Identity");
            append_hf("P-Asserted-Identity: <sip:$var(caller)@$(ai{uri.host})>\r\n");
        }
    } else if (is_present_hf("Remote-Party-ID") && $(re{uri.user}) != $var(caller)) {
        remove_hf("Remote-Party-ID");
        append_hf("Remote-Party-ID: <sip:$var(caller)@$(re{uri.host})>\r\n");
    } else {
        $fU = $var(caller);
        $fn = $var(caller);
    }
}

# Sets $var(callee) and $var(caller)
route[TRANSFORMATE_OUT] {
    sql_xquery("cb", "SELECT callee_out, caller_out FROM PeeringContracts PC LEFT JOIN TransformationRulesetGroupsTrunks TR ON PC.transformationRulesetGroupsTrunksId=TR.id WHERE PC.id=$avp(peeringContractId)", "ra");

    # Transformate caller_out (set result in $var(caller))
    route(GET_CALLER); # Greps caller and sets it in $var(caller)
    $var(transformation) = $xavp(ra=>caller_out);
    $var(number) = $var(caller);
    route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
    $var(caller) = $var(transformated);

    # -- Apply the same transformation to Diversion header
    if (is_present_hf("Diversion")) {
        $var(number) = $(di{uri.user});
        $avp(reason) = @hf_value.diversion[0].param['reason'];
        route(APPLY_TRANSFORMATION); # Apply $var(transformation) to $var(number)
        remove_hf("Diversion");
        add_diversion("$avp(reason)", 'sip:' + "$var(transformated)" + '@' + $dlg_var(companyDomain));
    }

    # Transformate callee_out
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSFORMATE-OUT: Initial callee -> $rU\n");
    $var(transformation) = $xavp(ra=>callee_out);
    $var(number) = $rU;
    route(APPLY_TRANSFORMATION);
    $var(callee) = $var(transformated);
}

# Apply $var(transformation) transformations (if set) to $var(number)
# Sets result in $var(transformated)
route[APPLY_TRANSFORMATION] {
    $var(transformated) = $var(number);
    $avp(appliedrule) = $null;

    dp_translate("$(var(transformation){s.int})", "$var(number)/$var(transformated)");

    # If no rule applied, re-set value
    if ($avp(appliedrule) == $null)
        $var(transformated) = $var(number);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] APPLY-TRANSFORMATION: Number after: $var(transformated) (applied rule: '$avp(appliedrule)')\n");
}

route[GET_INFO_FROM_MATCHED_DDI] {
    sql_xquery("cb", "SELECT d.DDIE164 AS DDI, d.billInboundCalls, d.peeringContractId, c.name AS companyName, c.id AS companyId, c.mediaRelaySetsId, c.brandId AS brandId, c.maxCalls AS maxCallsCompany, b.maxCalls AS maxCallsBrand, d.routeType, CS.calling_code AS company_cc, d.recordCalls, c.distributeMethod, AppS.ip AS asAddress FROM DDIs d JOIN Companies c ON d.companyId=c.id LEFT JOIN Countries CS ON CS.Id=c.countryId LEFT JOIN ApplicationServers AppS ON AppS.id=c.applicationServerId JOIN Brands b ON c.brandId=b.id WHERE d.DDIE164='$rU'", "ra");

    # Matched DDI
    $dlg_var(DDI) = $xavp(ra=>DDI);
    $dlg_var(brandId) = $xavp(ra=>brandId);
    $dlg_var(companyId) = $xavp(ra=>companyId);
    $dlg_var(companyName) = $xavp(ra=>companyName);
    $dlg_var(maxCallsCompany) = $xavp(ra=>maxCallsCompany);
    $dlg_var(maxCallsBrand) = $xavp(ra=>maxCallsBrand);
    $dlg_var(billInboundCalls) = $xavp(ra=>billInboundCalls);

    if ($dlg_var(billInboundCalls)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-MATCHED-DDI: peeringContractId: $xavp(ra=>peeringContractId)\n");
        $dlg_var(peeringContractId) = $xavp(ra=>peeringContractId);
    }

    # Recording settings
    if ($xavp(ra=>recordCalls) == 'inbound' || $xavp(ra=>recordCalls) == 'all') {
        $avp(recordCall) = 'yes';
    }

    $dlg_var(routeType) = $xavp(ra=>routeType);

    $dlg_var(company_cc) = $xavp(ra=>company_cc);
    if ($dlg_var(company_cc) == $null) {
        $dlg_var(company_cc) = 34;
    }

    $avp(distributeMethod) = $xavp(ra=>distributeMethod);
    $avp(asAddress) = $xavp(ra=>asAddress);

    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
}

# Handle within-dialog messages
route[WITHINDLG] {
    if (!$dlg_var(confirmed) && is_method("UPDATE|INVITE")) drop;

    # REFER not allowed
    if (is_method("REFER")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: 'REFER' not supported\n");
        send_reply("405","Method Not Allowed");
        exit;
    }

    # Reinvite handling
    if (is_method("INVITE")) {
        # uac_replace_from does not maintain display_name in subsequent transactions
        $fn = $dlg_var(newfromdisplay);

        #!ifdef DELAY_MEDIALIBERATION
        if ($dlg_var(initial_reinvite) == 'pending') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: Initial reinvite from call initiated by AS\n");
            $dlg_var(initial_reinvite) = 'yes';
        } else {
            $dlg_var(initial_reinvite) = 'no';
        }
        #!endif
    }

    # Fix overridden R-URI if needed
    if (!ds_is_from_list("1") && $dlg_var(contact) != $null && uri != $dlg_var(contact)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: Fix overridden contact ($ru -> $dlg_var(contact))");
        $ru = $dlg_var(contact);
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        } else if ( is_method("ACK") ) {
            # ACK is forwarded statelessy
            route(RTPRELAY);
        }
        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        send_reply("403","Not here");
    }
    exit;
}

route[DISPATCH] {
    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Static routing to specific AS?
    if ($avp(distributeMethod) == 'static') {
        $du = "sip:" + $avp(asAddress) + ":6060";
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: Company has static routing enabled\n");
        t_on_failure("MANAGE_FAILURE");
    } else {
        if ($avp(distributeMethod) == 'hash') {
            $avp(hash) = $dlg_var(companyId);
            # hash over $avp(hash)
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: Dispatch hashing '$avp(hash)'\n");
            $var(alg) = 7;
        } else {
            # round robin dispatching on ASs (distributeMethod == 'rr')
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: dispatch to any AS (round robin)\n");
            $var(alg) = 4;
        }

        if(!ds_select_dst("1", "$var(alg)")) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: No destination found\n");
            send_reply("404", "No destination");
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: $avp(AVP_CNT) destination(s) found\n");
        }

        t_on_failure("MANAGE_FAILURE_AS");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du>\n");
    t_on_branch("MANAGE_BRANCH_AS");
}

# Relay request
route[RELAY] {
    if ($(du{uri.host}) != $null)
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Relaying to $(du{uri.host}) (du, $dP)\n");
    else
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Relaying to $(ru{uri.host}) (ru)\n");

    # Common for every reply
    t_on_reply("MANAGE_REPLY");

    if (!t_is_set("branch_route")) {
        if (!has_totag() && is_method("CANCEL")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_BRANCH for CANCEL of initial transaction\n");
        } else if (!has_totag()) {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_BRANCH, this should not happen for an initial request\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_BRANCH for non-initial transaction\n");
        }
        t_on_branch("MANAGE_BRANCH");
    }

    if (!t_is_set("failure_route")) {
        if (!has_totag() && is_method("CANCEL")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_FAILURE for CANCEL of initial transaction\n");
        } else if (!has_totag()) {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_FAILURE, this should not happen for an initial request\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELAY: Setting MANAGE_FAILURE for non-initial transaction\n");
        }
        t_on_failure("MANAGE_FAILURE");
    }

    if (!t_relay())
        sl_reply_error();

    exit;
}

route[ANTIFLOOD] {
#!ifdef WITH_ANTIFLOOD
    # AS or myself
    if (src_ip==myself || ds_is_from_list("1")) return;

    # Trusted sources
    if (allow_trusted($si, 'any')) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (IP added in antiflood trusted IPs)\n");
        return;
    }

    # Evaluate PIKE
    if($sht(ipban=>$si) != $null) {
        # ip is already blocked
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
        exit;
    }
    if (!pike_check_req()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
        $sht(ipban=>$si) = 1;
        exit;
    }
#!endif

    return;
}

# Configure xlog
route[CONFIGURE_XLOG] {
    # Evaluate only once for SIP methods than can initiate transaction
    if ($dlg_var(log) == "0" || $dlg_var(log)) return;

    $dlg_var(log) = "0";

    if (is_method("INVITE") && $sel(cfg_get.dolog.invite)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REGISTER") && $sel(cfg_get.dolog.register)) {
        $dlg_var(log) = "1";
    }

    if (is_method("PUBLISH") && $sel(cfg_get.dolog.publish)) {
        $dlg_var(log) = "1";
    }

    if (is_method("SUBSCRIBE") && $sel(cfg_get.dolog.subscribe)) {
        $dlg_var(log) = "1";
    }

    if (is_method("NOTIFY") && $sel(cfg_get.dolog.notify)) {
        $dlg_var(log) = "1";
    }

    if (is_method("OPTIONS") && $sel(cfg_get.dolog.options)) {
        $dlg_var(log) = "1";
    }

    if (is_method("MESSAGE") && $sel(cfg_get.dolog.message)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REFER") && $sel(cfg_get.dolog.refer)) {
        $dlg_var(log) = "1";
    }

    # Needed variables
    if ($dlg_var(cidhash) == $null) {
        # Extract brandId (if present)
        if (is_present_hf('X-Info-BrandId')) {
            $dlg_var(brandId) = $hdr(X-Info-BrandId);
        } else {
            if (is_method("INVITE")) {
                sql_query("cb", "SELECT brandId FROM DDIs WHERE DDI='$rU' OR DDIE164='$rU'", "ra");
                if ( $dbr(ra=>rows) == 1 ) {
                    $dlg_var(brandId) = $dbr(ra=>[0,0]);
                } else {
                    if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] '$rU' not recognized easily\n");
                }
                sql_result_free("ra");
            }
        }

        # Calculate callid hash
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});
        if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calculated hash for $rm $ci\n");
    }

    return;
}

route[SAVE_CONTACT] {
    if (!is_present_hf("Contact") || $dlg_var(contact) != $null) return;

    if ($ct =~ "<.*>") {
        # Contact has < >
        $var(contact) = $(ct{s.select,0,>});
        $var(contact) = $(var(contact){s.select,1,<});
    } else {
        $var(contact) = $ct;
    }

    $dlg_var(contact) = $var(contact);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SAVE-CONTACT: Save inside contact $dlg_var(contact)");
}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    # Set proxy value
    $dlg_var(proxy) = 'PSTN';

    # Where is my caller? Order: PAI, RPID, From
    if (is_present_hf("P-Asserted-Identity")) {
        $dlg_var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        $dlg_var(caller) = $(re{uri.user});
    } else {
        $dlg_var(caller) = $fU;
    }

    $dlg_var(callee) = $rU;
    $dlg_var(callid) = $ci;
    if (is_present_hf("Diversion")) {
        $dlg_var(diversion) = $(di{uri.user});

        # Extract X-Info-ForwardExt: (internal extension for outbound fw)
        $var(header) = 'X-Info-ForwardExt';
        route(PARSE_OPTIONAL_X_HEADER);
        if ($(var(header-value){s.len}) > 0 && $var(header-value) != $(di{uri.user})) {
            $dlg_var(diversion) = $dlg_var(diversion) + ' (' + $var(header-value) + ')';
        }
    }

    if (is_present_hf("Referred-by")) {
        $dlg_var(referrer) = $(hdr(Referred-by){nameaddr.uri}{uri.user});
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Call due to bxfer from $dlg_var(referrer)\n");
        remove_hf("Referred-by");
    }

}

# Reply generic route (all replies goes through this route)
onreply_route {
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ( $rm =~ $sel(cfg_get.dolog.printmsg_methods) ) xlog("L_WARN", "Received reply:\n\n$mb\n");
}

# Common for both AS and GW replies
onreply_route[MANAGE_REPLY] {
    # Manage RTP
    if (t_check_status("[12][0-9]{2}")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-REPLY: Non-error reply $rs, call RTPRELAY\n");
        route(RTPRELAY);
    }

    if (t_check_status("2[0-9]{2}") && ds_is_from_list("1")) {
        route(SAVE_CONTACT);
    }
}

# Manage failure replies (only for failure response codes, executed after previous 2 routes)

# Failure route for initial transactions to GW
failure_route[MANAGE_FAILURE_GW] {
    if(!t_check_status("(401)|(407)")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    }

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: t_is_canceled, exit here\n");
        exit;
    }

    if (t_check_status("(401)|(407)") && $avp(auth_done) != '1') {
        # Get ready for SIP auth
        #   username:  $avp(provideruser) set in SELECT-GW
        #   password:  $avp(secret) from DB below
        #   realm:     take it from 401/407 leaving it empty
        $avp(realm) = '';

        # $avp(secret) is available?
        if (is_avp_set("$avp(secret)")) {
            # Sends INVITE with AUTH (and adapts CSeq)
            uac_auth();
            $avp(auth_done) = '1'; # Set avp to avoid using invalid credentials more than once
            # Ensure last chosen GW du and ru are used in subsequent auth process
            $du = $avp(du_after_lcr);
            $ru = $avp(ru_after_lcr);

            t_on_failure("MANAGE_FAILURE_GW");
            t_on_branch("MANAGE_BRANCH_GW");
            route(RELAY);
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: No secret available for $avp(newfrom), defunct_gw and try another one\n");
            defunct_gw(36000); # No credentials available, defunct gw 4ever and trigger alarm
        }
    } else if (t_check_status("(401)|(407)") && $avp(auth_done) == '1') {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Invalid credentials already used\n");
    } else if (t_check_status("480|486")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Forward response downstream (reply code: $T_reply_code)\n");
        exit;
    } else if (t_check_status("422")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Session Interval Too Small, forward to AS (reply code: $T_reply_code)\n");
        exit;
    } else if (t_check_status("408")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code: Inactivate GW\n");
        inactivate_gw(); # Inactivate GW temporally (until it answers OPTIONS)
    } else if (t_check_status("3[0-9]{2}")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: $T_reply_code: Not allowed from GW\n");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Failure using gateway to place a call (reply code: $T_reply_code)\n");

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-GW: Try next GW\n");
    route(SELECT_GW);

    t_on_failure("MANAGE_FAILURE_GW");
    t_on_branch("MANAGE_BRANCH_GW");
    route(RELAY);
}

# Failure route for initial transactions to AS
failure_route[MANAGE_FAILURE_AS] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS '$avp(AVP_DST)' as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            t_on_branch("MANAGE_BRANCH_AS");
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Failure route for non-initial transactions
failure_route[MANAGE_FAILURE] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: t_is_canceled, exit here\n");
        exit;
    }
}

# Route for branching to GWs: Only for INVITEs and BYEs (fork-able)

# Branch route for initial transactions to GW
branch_route[MANAGE_BRANCH_GW] {
    route(RTPRELAY);

    # In initial request, adapt From, To, PAI and RPID to what selected gateway expects

    # avp(caller_method): bitwise flag ABC (in DB integer from 0-7)
    # A: auth_username as from_user flag (4)
    # B: RPID flag (2)
    # C: PAI flag (1)
    #
    # e.g. 5: Use auth_username as from_user and use PAI header

    # Asterisk must never send PAI header when talking to proxytrunks
    if (is_present_hf("P-Asserted-Identity")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Received P-Asserted-Identity header from AS, this should NEVER happen\n");
    }

    # Asterisk should never send RPID header when talking to proxytrunks
    if (is_present_hf("Remote-Party-ID")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Received Remote-Party-ID header from AS, this should NEVER happen\n");
    }

    # Get transformed caller (From) and callee (in $var(callee) and $var(caller))
    route(TRANSFORMATE_OUT);
    $rU = $var(callee);

    # Caller after transformations
    $avp(newfromuser) = $var(caller);
    $avp(newfromdomain) = $Ri; # Use bind ip as from domain
    $avp(newfromuri) = 'sip:' + $avp(newfromuser) + '@' + $avp(newfromdomain);
    # Keep this in dlg_var as uac_replace_from does not work for display name
    $dlg_var(newfromdisplay) = '"' + $avp(newfromuser) + '"'; # "Like this" (entrecomillado)

    # Use PAI?
    if (avp_check("$avp(caller_method)", "and/i:0x01")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Set PAI to: $dlg_var(newfromdisplay) <$avp(newfromuri)>\n");
        append_hf("P-Asserted-Identity: $dlg_var(newfromdisplay) <$avp(newfromuri)>\r\n");
    }

    # Use RPID?
    if (avp_check("$avp(caller_method)", "and/i:0x02")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Set RPID to: $dlg_var(newfromdisplay) <$avp(newfromuri)>\n");
        append_hf("Remote-Party-ID: $dlg_var(newfromdisplay) <$avp(newfromuri)>;privacy=off;screen=no\r\n");
    }

    # Modify from_user and from_domain if necessary
    if ( $avp(from_user) != $null && $avp(from_domain) != $null ) {
        $avp(newfromuri) = "sip:" + $avp(from_user) + '@' + $avp(from_domain);
    } else if ($avp(from_user) != $null) {
        $avp(newfromuri) = "sip:" + $avp(from_user) + '@' + $avp(newfromdomain);
    } else if ($avp(from_domain) != $null) {
        $avp(newfromuri) = "sip:" + $avp(newfromuser) + '@' + $avp(from_domain);
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: New from: $dlg_var(newfromdisplay) <$avp(newfromuri)>\n");
    uac_replace_from('$dlg_var(newfromdisplay)', "$avp(newfromuri)"); # Cambio el From (se auto cambiara en la respuesta)

    # To should be equal to RURI
    $avp(newto) = $ru;
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: New to: $avp(newto)\n");
    uac_replace_to("$avp(newto)"); # Cambio el To (se auto cambiara en la respuesta)

    # Add GW prefix if necessary
    if ($avp(gw_prefix) != $null) {
        $rU = $avp(gw_prefix) + $rU;
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH-GW: Add GW prefix, new ruri-user: $rU\n");
    }
}

# Branch route for initial transactions to AS
branch_route[MANAGE_BRANCH_AS] {
    route(RTPRELAY);
}

# Branch route for non-initial transactions
branch_route[MANAGE_BRANCH] {
    route(RTPRELAY);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $dlg_var(direction) call confirmed for company '$dlg_var(companyId)' [$ci]\n");

    if (!ds_is_from_list("1")) {
        $dlg_var(peeringContractId) = $avp(peeringContractId);
        if (!$(dlg_var(peeringContractId){s.len})) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] [b$dlg_var(brandId)][$dlg_var(cidhash)] Problems obtaining peeringContractId, THIS CALL WILL NOT BE BILLED ($ci)!\n");
        }
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $dlg_var(direction) call ended for company '$dlg_var(companyId)' [$ci]\n");
}

# Executed for request generated by Kamailio
event_route[tm:local-request] {
    xlog("L_NOTICE","Kamailio generated request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");

    // UACREG sends REGISTER requests whose Contact domain must be addapted
    if ($rm == "REGISTER") {
        subst_hf("Contact", "/reg_contact_addr/$sndfrom(ip):$sndfrom(port)/", "a");
    }
}

onsend_route {
    if (is_method("ACK")) $dlg_var(confirmed) = '1';

    #!ifdef DELAY_MEDIALIBERATION
    if (is_request() && is_method("INVITE") && $dlg_var(initial_reinvite) == 'yes') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Initial reinvite from call initiated by AS, delay 1 second\n");
        sleep(1);
    }
    #!endif

    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) {
        if (is_request())
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent request:\n\n$snd(buf)\n");
        else
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent reply:\n\n$snd(buf)\n");
    }
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_WARN", "XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");
    route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "GENERIC_XMLRPC_COMMAND: XMLRPC generic command from allowed IP ($si), dispatch!\n");

    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[RTPRELAY] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;
    if (is_method("ACK") && !has_body("application/sdp")) return;

    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPRELAY: Custom rtpproxy set: $dlg_var(mediaRelaySetsId)\n");
        set_rtp_proxy_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    rtpproxy_manage("coarf");

    if (is_request() && is_method("INVITE") && !has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPRELAY: Chosen RTPproxy instance $var(RTP_INSTANCE)\n");
    }

    if ($avp(recordCall) == 'yes' && $dlg_var(recordingCall) != 'yes') {
        # First 200 OK to initial INVITE
        if (is_reply() && t_check_status("2[0-9]{2}")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPRELAY: Start recording this call ('$rs $rr' for initial $rm)\n");
            start_recording();
            $dlg_var(recordingCall) = 'yes'; # Save to avoid start_recording twice if retrans
        }
    }
}

route[CONTROL_MAXCALLS] {
    if (get_profile_size("activeCallsCompany", "$dlg_var(companyId)", "$avp(activeCallsCompany)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany) calls\n");
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: company$dlg_var(companyId) $avp(activeCallsCompany)/$dlg_var(maxCallsCompany) calls (error obtaining value)\n");
        if ($dlg_var(maxCallsCompany) > 0) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: Dropping call for security\n");
            send_reply("500", "Internal Server Error [MC]");
            exit;
        }
    }

    if (get_profile_size("activeCallsBrand", "$dlg_var(brandId)", "$avp(activeCallsBrand)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand) calls\n");
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: brand$dlg_var(brandId) $avp(activeCallsBrand)/$dlg_var(maxCallsBrand) calls (error obtaining value)\n");
        if ($dlg_var(maxCallsBrand) > 0) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: Dropping call for security\n");
            send_reply("500", "Internal Server Error [MC]");
            exit;
        }
    }

    if ($dlg_var(maxCallsBrand) > 0 && $avp(activeCallsBrand) >= $dlg_var(maxCallsBrand)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: Call NOT allowed for brand$dlg_var(brandId), 403 Forbidden [MC]\n");
        send_reply("403", "Forbidden [MC]");
        exit;
    } else if ($dlg_var(maxCallsCompany) > 0 && $avp(activeCallsCompany) >= $dlg_var(maxCallsCompany)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: Call NOT allowed for company$dlg_var(companyId), 403 Forbidden [MC]\n");
        send_reply("403", "Forbidden [MC]");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] CONTROL-MAXCALLS: Call ALLOWED for brand$dlg_var(brandId) - company$dlg_var(companyId)\n");
        set_dlg_profile("activeCallsCompany", "$dlg_var(companyId)");
        set_dlg_profile("activeCallsBrand", "$dlg_var(brandId)");
    }
}

