#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define SIP_PORT 5060
#!define SIPS_PORT 5061
#!define XMLRPC_PORT 8000
#!define WS_PORT 10080
#!define WSS_PORT 10081

#
# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# FTL_NATS: Tags the transaction as behind NAT. It uses nat_uac_test(18) as NAT-detection mechanism
# 18: 2 + 16
# 2 - the "received" test is used: address in the "Via" header is compared against source IP address of signaling
# 16 - Test if the source port is different from the port in the "Via" header

#!define FLT_NATS 1

# FLB_NATB: Tags the branch as behind NAT.
# Is is set in 2 cases:
# 1. REGISTER behind NAT (received IP:PORT are saved in usrloc table)
# 2. Within-dialog request with nat=yes in Route header (added by this proxy in Record-route of initial transaction)

#!define FLB_NATB 2

# FLB_NATSIPPING: Enables SIP-pinging using OPTIONS for UACs registered behind NAT (see case 1 FLB_NATB)
#!define FLB_NATSIPPING 3

# DLG_FLAG
#!define DLG_FLAG 4

# ACC Flags
#!define FLT_ACC 5
#!define FLT_ACCMISSED 6
#!define FLT_ACCFAILED 7

# Marked for branches involving wss
#!define FLB_WEBSOCKETS 8

# - options
#!define WITH_ANTIFLOOD

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

####### Runtime cfg values (kamcmd cfg.list) #########

# Log dialogs initiated by these SIP methods
dolog.invite    = 1 desc "If 1, log invite transactions"
dolog.register  = 1 desc "If 1, log register transactions"
dolog.publish   = 1 desc "If 1, log publish transactions"
dolog.subscribe = 1 desc "If 1, log subscribe transactions"
dolog.notify    = 1 desc "If 1, log notify transactions"
dolog.options   = 1 desc "If 1, log options transactions"
dolog.message   = 1 desc "If 1, log message transactions"
dolog.refer     = 1 desc "If 1, log refer transactions"
dolog.websocket = 1 desc "If 1, debug WS connection upgrade"

# Debug
dolog.xmlrpc    = 0 desc "If 1, debug XMLRPC"
dolog.printmsg_methods = 'NONE' desc "Print full SIP messages with these methods" # e.g. 'INVITE|REGISTER', 'NONE' to disable

####### Global Parameters #########

listen=udp:IP:SIP_PORT
listen=tcp:IP:SIP_PORT
listen=tls:IP:SIPS_PORT
listen=tcp:IP:XMLRPC_PORT
listen=tcp:IP:WS_PORT
listen=tls:IP:WSS_PORT

tcp_accept_no_cl=yes # Needed for WS

# -- Debug level
# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# If debug level of message is lower than current debug parameter, it gets printed
# Current value: 2 (INFO and higher)
#
# This setting can me modified/seen live running:
# kamcmd-proxyusers cfg.seti core debug X
# kamcmd-proxyusers cfg.get core debug

debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes
version_table="kam_version"

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec Ivoz Provider v1.0"
user_agent_header="User-Agent: Irontec Ivoz Provider v1.0"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "mi_fifo.so"
loadmodule    "mi_rpc.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "usrloc.so"
loadmodule    "registrar.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "nathelper.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "permissions.so"
loadmodule    "sqlops.so"
loadmodule    "cfg_rpc.so"
loadmodule    "acc.so"
loadmodule    "dialog.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "auth.so"
loadmodule    "auth_db.so"
loadmodule    "domain.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "corex.so"
loadmodule    "rtpengine.so"
loadmodule    "websocket.so"
loadmodule    "xhttp.so"
loadmodule    "jsonrpc-s.so"
loadmodule    "json.so"
loadmodule    "rtpproxy.so"
loadmodule    "pua.so"
loadmodule    "pua_dialoginfo.so"
loadmodule    "presence.so"
loadmodule    "presence_xml.so"
loadmodule    "presence_dialoginfo.so"
loadmodule    "ipops.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# RTPENGINE
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:22223")

# RTPPROXY
modparam("rtpproxy", "db_url", DBURL)
modparam("rtpproxy", "table_name", "kam_rtpproxy")
modparam("rtpproxy", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpproxy", "nortpproxy_str", "a=sdpmangled:yes\r\n")

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_DSSOCKET)")
modparam("dispatcher", "attrs_avp", "$avp(DSATTRS)")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_mode", 2)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@users.ivozprovider.local")
modparam("dispatcher", "hash_pvar", "$avp(hash)")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxyusers_ctl")

# TLS
modparam("tls", "config", "/etc/kamailio/proxyusers/tls.cfg")
modparam("tls", "tls_log", 2)

# MI_FIFO
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_proxyusers_fifo")

# USRLOC
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc|tm", "xavp_contact", "ulattrs")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# NAT
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")

# REGISTER
modparam("registrar", "min_expires", 300)
modparam("registrar", "max_contacts", 5)

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_users_address") # Allowed networks per company
modparam("permissions", "trusted_table", "kam_pike_trusted") # IPs excluded from pike checking
modparam("permissions", "db_mode", 1)
modparam("permissions", "grp_col", "companyId")
modparam("permissions", "max_subnets", 4096)

# ACC
# -- transactions to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "acc_time_column", "localtime")
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- cdr accounting to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 0)
modparam("acc", "cdrs_table", "kam_acc_cdrs")
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "proxy=$dlg_var(proxy);brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);referrer=$dlg_var(referrer);referee=$dlg_var(referee);direction=$dlg_var(direction)")

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "callsPerAor; outgoingCallsPerAor")
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "default_timeout", 10800) # 3 hours
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n") # Added to requests generated locally by the module (e.g. BYE)

# TM
modparam("tm", "fr_timer", 5000)
modparam("tm", "contacts_avp", "tm_contacts")
modparam("tm", "contact_flows_avp", "tm_contact_flows")
modparam("tm", "local_cancel_reason", 200)

# AUTH_DB
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "user_column", "name")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "domain_column", "domain")
modparam("auth_db", "use_domain", 1)

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif

# dialogs htable contains aleg, bleg and applicationserver per dialog
modparam("htable", "htable", "dialogs=>size=10;autoexpire=0")

# SANITY
modparam("sanity", "autodrop", 0)

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_users_domain")
modparam("domain", "domain_attrs_table", "kam_users_domain_attrs")
modparam("domain", "register_myself", 1)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

# PRESENCE
modparam("presence", "db_url", DBURL)
modparam("presence", "presentity_table", "kam_users_presentity")
modparam("presence", "active_watchers_table", "kam_users_active_watchers")
modparam("presence", "watchers_table", "kam_users_watchers")
modparam("presence", "min_expires", 1800)
modparam("presence", "max_expires", 3600)
modparam("presence", "db_update_period", 100)
modparam("presence", "subs_db_mode", 2)

# PRESENCE XML
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "xcap_table", "kam_users_xcap")
modparam("presence_xml", "force_active", 1)

# PRESENCE XML
modparam("presence_dialoginfo", "force_single_dialog", 1)
modparam("presence_dialoginfo", "force_dummy_dialog", 1)

# PUA
modparam("pua", "db_url", DBURL)
modparam("pua", "db_table", "kam_users_pua")
modparam("pua", "db_mode", 0)
modparam("pua", "update_period", 100)

# PUA_DIALOGINFO
# -- needed for call-pickup
modparam("pua_dialoginfo", "include_callid", 0)
modparam("pua_dialoginfo", "include_tags", 0)
modparam("pua_dialoginfo", "include_localremote", 0)
modparam("pua_dialoginfo", "caller_confirmed", 0)
modparam("pua_dialoginfo", "use_pubruri_avps", 1)
modparam("pua_dialoginfo", "pubruri_caller_avp", "$avp(pubruri_caller)")
modparam("pua_dialoginfo", "pubruri_callee_avp", "$avp(pubruri_callee)")
modparam("pua_dialoginfo", "pubruri_caller_dlg_var", "pubruri_caller")
modparam("pua_dialoginfo", "pubruri_callee_dlg_var", "pubruri_callee")

####### Routing Logic ########

request_route {
    # per request initial checks
    route(REQINIT);

    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Request: $rm '$ru' ($cs $rm) from '$fu' ($si:$sp) [$proto]\n");

    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) xlog("L_WARN", "Received message:\n\n$mb\n");

    if (is_method("OPTIONS")) {
        force_rport();
        send_reply("200", "I'm here!");
        exit;
    }

    route(ANTIFLOOD);

    # NAT/WS detection
    if (nat_uac_test(64)) # 64 - Test if the source connection of signaling is WS
        route(WSFIX);
    else
        route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si\n");
        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RELAY);
        }

        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # Manage retransmissions
    if (!is_method("ACK")) {
        if(t_precheck_trans()) {
            t_check_trans();
            exit;
        }
        t_check_trans();
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        route(WITHINDLG);
    }

    ### only initial requests (no To tag)

    # Discard unsupported methods
    if (!is_method("INVITE|REGISTER|SUBSCRIBE|NOTIFY|PUBLISH")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Manage authentication
    route(AUTH);

    # Remove preloaded route headers
    remove_hf("Route");

    # Handle REGISTER
    route(REGISTER);

    # Add record-route to INVITE and SUBSCRIBE requests
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # Handle SUBSCRIBE and PUBLISH
    route(PRESENCE);

    # Handle out-of-dialog NOTIFY
    route(NOTIFY);

    # From now on, everything is for INVITEs: track dialog

    # Setup accounting
    route(ACCOUNTING);

    # Set caller and callee to generate PUBLISH
    route(GENERATE_PUBLISH);

    if (!is_known_dlg()) {
        dlg_manage();
    } else {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Avoiding duplicate call to dlg_manage() for known dialog\n");
    }

    # Route AS or subscriber calls
    if (ds_is_from_list("1")) {
        if (!is_present_hf("X-Info-Conf")) {
            # (a) AS calling
            $dlg_var(direction) = 'outbound';

            # Save CallID <-> AS relationship
            $sht(dialogs=>$ci::applicationserver) = 'sip:' + $si + ':6060';

            route(REPLACES);
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AS calling to local subscriber, relay to subcriber\n");
            route(PARSE_X_HEADERS);
            route(MAXCALLS_USER);
            route(FRIENDS);
            route(RETAILS);
            route(LOOKUP);
        } else {
            # ACC CDR insert will fail, but that's OK
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AS calling to conference room, proceed\n");
            route(DISPATCH);
        }
    } else {
        # (b) Subscriber calling
        $dlg_var(direction) = 'inbound';

        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Local subscriber calling to my domain, dispatch to AS(-es)\n");
        route(GET_INFO_FROM_CALLER);
        route(FILTER_BY_SCR_ADDR);
        if ($rU =~ '^\*') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calling to feature-like $rU\n");
        }

        route(DISPATCH);
    }

    route(RELAY);
}

route[REQINIT] {
    # Easy dropping for scanners
    if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent" || search("sipvicious")) {
        xlog("L_WARN", "REQINIT: Dropping scanner request ----> $rm from $si\n");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        xlog("L_ERR", "REQINIT: Dropping malformed SIP message from $si:$sp\n");
        exit;
    }

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        xlog("L_ERR", "REQINIT: Too many hops for SIP message from $si:$sp\n");
        send_reply("483","Too Many Hops");
        exit;
    }
}

route[GENERATE_PUBLISH] {
    if (ds_is_from_list("1")) {
        # No PUBLISH for calls to friends/retails
        if (is_present_hf("X-Info-Friend")) return;
        if (is_present_hf("X-Info-Retail")) return;

        # Set X-Info-Callee as 'callee' instead of user in To header
        $avp(pubruri_callee)= "sip:" + $hdr(X-Info-Callee) + "@" + $fd;
    } else {
        sql_xquery("cb", "SELECT extension, externalIpCalls FROM kam_users_exten WHERE name='$fU' AND domain='$fd'", "rp");
        if ($xavp(rp=>extension) == $null) return; # No PUBLISH for calls from non-terminals

        # Terminal calling
        # Set user extension as 'caller' instead of user in From header
        $avp(pubruri_caller)= "sip:" + $xavp(rp=>extension) + "@" + $fd;

        $dlg_var(caller) = $xavp(rp=>extension); # Set accounting dlg_var too

        # Is this user allowed to call from non-granted IPs?
        $avp(externalIpCalls) = $xavp(rp=>externalIpCalls);
    }
}

route[MAXCALLS_USER] {
    if (!$dlg_var(maxcallsUser)){
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MAXCALLS-USER: '$tU@$td' has no call-limit, proceed\n");
        return;
    }

    get_profile_size("callsPerAor", "$tU@$td", "$var(currentCalls)");
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MAXCALLS-USER: '$tU@$td' has $var(currentCalls) out of $dlg_var(maxcallsUser) active calls\n");

    if ($var(currentCalls) >= $dlg_var(maxcallsUser)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MAXCALLS-USER: Reject call\n");
        send_reply("486", "Maxcalls exceeded");
        exit;
    } else {
        $avp(AoR) = $tU + '@' + $td;
    }
}

route[REPLACES] {
    if (! is_present_hf("Replaces")) return;

    # AS sending an INVITE with REPLACE header, guess which AS is the proper destination
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: AS sending a INVITE with Replaces header, forward to proper AS\n");

    # Extract CallId from Replaces header
    $var(replace_uri) = $(hdr(Replaces){s.select,0,;});
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: Which AS is handling $(hdr(Replaces){s.select,0,;})?\n");

    if ($sht(dialogs=>$var(replace_uri)::applicationserver) != $null) {
        $du = $sht(dialogs=>$var(replace_uri)::applicationserver);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: Forward to '$du'\n");
        $fu = 'sip:replacer@users.ivozprovider.local'; # Change From header too
        route(RELAY);
    } else {
        if ($dlg_var(log)) xlog("L_ERROR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: CallID not found, 500\n");
        send_reply("500", "CallID not found");
        exit;
    }
    # Note: this dialog won't be inserted into kam_acc_cdrs (INSERT fails) and that's OK
}

route[DISPATCH] {
    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Static routing to specific AS?
    if ($avp(distributeMethod) == 'static') {
        $du = "sip:" + $avp(asAddress) + ":6060";
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: Company has static routing enabled\n");
        t_on_failure("MANAGE_FAILURE");
    } else {
        if (is_present_hf("X-Info-Conf")) {
            # hash over request-URI
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: Dispatch conference to convenient AS (R-URI hash)\n");
            $var(alg) = 3;
        } else if ($avp(distributeMethod) == 'hash') {
            $avp(hash) = $dlg_var(companyId);
            # hash over $avp(hash)
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: Dispatch hashing '$avp(hash)'\n");
            $var(alg) = 7;
        } else {
            # round robin dispatching on ASs (distributeMethod == 'rr')
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: dispatch to any AS (round robin)\n");
            $var(alg) = 4;
        }

        if(!ds_select_dst("1", "$var(alg)")) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: No destination found\n");
            send_reply("404", "No destination");
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: $avp(AVP_CNT) destination(s) found\n");
        }

        t_on_failure("MANAGE_FAILURE_AS");
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du>\n");

    # Save CallID <-> AS relationship
    $sht(dialogs=>$ci::applicationserver) = $du;
}

route[LOOKUP] {
    if ($avp(static_location) == 'yes') return;

    lookup("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Contact not found for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
        case -2:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Contacts found, but method not supported for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
        case -3:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Internal error during processing lookup for $ru, 404\n");
            send_reply("404", "Not Found");
            exit;
    };

    # Handle multiple contacts
    if (!t_load_contacts()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Error loading contacts for $rU\n");
        send_reply("500", "Server Internal Error - Cannot load contacts");
        exit;
    }

    # Load contact or contacts
    if (!t_next_contacts()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: t_next_contacts - One contact found for $tu, calling $ru\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: t_next_contacts - Multiple contacts found for $tu, parallel forking\n");
    }

    # Is this a call to a dynamic friend/retail?
    route(DYNAMIC_ENDPOINT);
}

route[DYNAMIC_ENDPOINT] {
    if (!is_method("INVITE")) return;
    if (!($dlg_var(friend) == 'dynamic' || $dlg_var(retail) == 'dynamic')) return;

    # Fix call destination to avoid sending call to user part of Contact header in REGISTER
    $rU = $dlg_var(callee);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DYNAMIC-ENDPOINT: This call is for a dynamic friend/retail, set destination to '$rU'\n");
}

route[FRIENDS] {
    if (!is_method("INVITE")) return;
    if ($dlg_var(friend) == $null) return;
    if ($dlg_var(friend) == 'dynamic') return;

    # Static friend
    $ru = $dlg_var(friend);
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FRIEND: It is a static friend, route to '$ru'\n");
    $avp(static_location) = 'yes';
}

route[RETAILS] {
    if (!is_method("INVITE")) return;
    if ($dlg_var(retail) == $null) return;
    if ($dlg_var(retail) == 'dynamic') return;

    # Static retail
    $ru = $dlg_var(retail);
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RETAILS: It is a static retail, route to '$ru'\n");
    $avp(static_location) = 'yes';
}

route[GET_INFO_FROM_CALLER] {
    # Get needed information from terminal name
    sql_xquery("cb", "SELECT KU.type AS callerType, C.id AS companyId, C.brandId AS brandId, C.name AS companyName, C.mediaRelaySetsId, C.ipFilter, C.distributeMethod, C.maxCalls AS maxCallsCompany, B.maxCalls AS maxCallsBrand, AppS.ip AS asAddress, C.onDemandRecord, C.onDemandRecordCode FROM kam_users KU LEFT JOIN Companies C ON C.id=KU.companyId JOIN Brands B ON C.brandId=B.id LEFT JOIN ApplicationServers AppS ON AppS.id=C.applicationServerId WHERE KU.name='$fU' AND KU.domain='$fd'", "ra");

    $dlg_var(brandId) = $xavp(ra=>brandId);
    $dlg_var(companyId) = $xavp(ra=>companyId);
    $dlg_var(companyName) = $xavp(ra=>companyName);
    $dlg_var(maxCallsCompany) = $xavp(ra=>maxCallsCompany);
    $dlg_var(maxCallsBrand) = $xavp(ra=>maxCallsBrand);
    $var(ipFilter) = $xavp(ra=>ipFilter);
    $avp(distributeMethod) = $xavp(ra=>distributeMethod);
    $avp(asAddress) = $xavp(ra=>asAddress);
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);

    if ($xavp(ra=>onDemandRecord)) {
        $dlg_var(onDemandRecordCode) = $xavp(ra=>onDemandRecordCode);
    }
}

route[FILTER_BY_SCR_ADDR] {
    if ($var(ipFilter) == '0') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: IP filter is disabled for company '$dlg_var(companyId)'\n");
        return;
    }

    # Company has IP check enabled

    if (allow_source_address($dlg_var(companyId))) {
        # -- Granted IP, proceed
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: Valid source $si for company '$dlg_var(companyId)'\n");
    } else if ($avp(externalIpCalls) > 0) {
        # -- Non-granted IP, but roadwarrior calling
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: This user is allowed to call from non-granted IP (externalIpCalls: $avp(externalIpCalls))\n");
        route(FILTER_BY_NUMCALLS);
    } else {
        # -- Non-granted IP and not roadwarrior
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: $si is not valid for company '$dlg_var(companyId)'\n");
        $rU = 'ipnotallowed';
    }
}

route[FILTER_BY_NUMCALLS] {
    get_profile_size("outgoingCallsPerAor", "$fU@$fd", "$var(currentOutgoingCalls)");
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-NUMCALLS: '$fU@$fd' has $var(currentOutgoingCalls) out of $avp(externalIpCalls) outgoing calls\n");

    if ($var(currentOutgoingCalls) >= $avp(externalIpCalls)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-NUMCALLS: Reject call\n");
        send_reply("486", "Maxcalls exceeded");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-NUMCALLS: Allow call\n");
        set_dlg_profile("outgoingCallsPerAor", "$fU@$fd");
    }
}

route[PARSE_X_HEADERS] {
    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(xcallid) = $var(header-value);
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Related leg: $dlg_var(xcallid)\n");

    # Extract callee
    $var(header) = 'X-Info-Callee';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(callee) = $var(header-value);

    # Extract user maxcalls
    $var(header) = 'X-Info-UserMaxCalls';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(maxcallsUser) = $var(header-value);

    # Extract brandId
    $var(header) = 'X-Info-BrandId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(brandId) = $var(header-value);

    # Extract companyId
    $var(header) = 'X-Info-CompanyId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyId) = $var(header-value);

    # Extract companyName
    $var(header) = 'X-Info-CompanyName';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyName) = $var(header-value);

    # Extract MediaRelaySet (can be null and non-exist)
    $var(header) = 'X-Info-MediaRelaySet';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(mediaRelaySetsId) = $var(header-value);

    # Extract RecordCode (can be null and non-exist)
    $var(header) = 'X-Info-RecordCode';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(onDemandRecordCode) = $var(header-value);

    # Extract Friend (can be null and non-exist)
    $var(header) = 'X-Info-Friend';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(friend) = $var(header-value);

    # Extract Retail (can be null and non-exist)
    $var(header) = 'X-Info-Retail';
    route(PARSE_OPTIONAL_X_HEADER);
    if ($var(header-value) != '') $dlg_var(retail) = $var(header-value);
}

# Header might not be present and, if present, might be empty
route[PARSE_OPTIONAL_X_HEADER] {
    if (is_present_hf($var(header))) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        $var(header-value) = '';
    }
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        send_reply("500", "Missing $var(header)");
        exit;
    }
}

# Authentication route
route[AUTH] {
    if (is_method("PUBLISH") && dns_sys_match_ip("users.ivozprovider.local", "$si")) return;

    if (ds_is_from_list("1")) {
        # No auth for AS requests
        return;
    }

    if (is_method("REGISTER") || from_uri==myself) {
        # authenticate requests
        if (!auth_check("$fd", "kam_users", "1")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AUTH: Auth needed\n");
            auth_challenge("$fd", "0");
            exit;
        }

        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AUTH: Authentication OK\n");
        # user authenticated - remove auth header
        consume_credentials();
    }

    # If caller is not local subscriber, reject (both AS and subscribers use my domain in from-domain)
    if (from_uri!=myself) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $fd is not my domain, 403 forbidden\n");
        send_reply("403","Forbidden");
        exit;
    }

    # Check R-URI is for my domain
    if (uri!=myself) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] R-URI not for my domain, 404 Not here\n");
        send_reply("404", "Invalid domain in R-URI");
        exit;
    }

    # Domain strict checking
    if ( uri == myself && !is_uri_host_local() ) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rd is my IP but domains should be used, reject\n");
        send_reply("488", "Domain needed");
        exit;
    }

    if ( from_uri == myself && !is_from_local() ) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $fd is my IP but domains should be used, reject\n");
        send_reply("488", "Domain needed");
        exit;
    }

    return;
}

# Handle within-dialog messages
route[WITHINDLG] {
    if (!$dlg_var(confirmed) && is_method("UPDATE|INVITE")) drop;

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(RURIALIAS);
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        } else if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("REFER")) {
            route(REFER);
        } else if (is_method("INFO")) {
            route(INFO);
        } else if (is_method("MESSAGE")) {
            route(MESSAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
    } else {
        if (is_method("SUBSCRIBE") && uri == myself) {
            # in-dialog subscribe requests
            route(PRESENCE);
            exit;
        }

        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        send_reply("404","Not here");
    }
    exit;
}

route[REFER] {
    if (is_present_hf("Refer-to") && $(hdr(Refer-to){s.len})) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REFER: $fU transfers call to $hdr(Refer-to)\n");
        $dlg_var(referee) = $hdr(Refer-to);

        if ($(hdr(Refer-to){nameaddr.uri}{uri.user}) =~ '^,?\*[0-9]{1,3}$') {
            $var(opt1) = ',*' + $dlg_var(onDemandRecordCode);
            $var(opt2) = '*' + $dlg_var(onDemandRecordCode);
            $var(code) = $(hdr(Refer-to){nameaddr.uri}{uri.user});

            if ($var(code) == $var(opt1) || $var(code) == $var(opt2)) {
                route(ONDEMANDRECORD);
            }

            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REFER: That is NOT the code, relay\n");
        }

    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REFER: No Refer-To header found, relay\n");
    }

    return;
}

route[INFO] {
    if (is_present_hf("Record")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] INFO: On demand record using INFO, proceed\n");
        route(ONDEMANDRECORD);
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] INFO: INFO without Record header, relay\n");
    }

    return;
}

route[MESSAGE] {
    if (!ds_is_from_list("1")) return;

    if (search_body("on-demand-record")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MESSAGE: On demand record using MESSAGE, proceed\n");
        route(ONDEMANDRECORD);
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MESSAGE: MESSAGE without on-demand-record body, relay\n");
    }

    return;
}

route[ONDEMANDRECORD] {
    if (!$dlg_var(onDemandRecordCode)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: On demand record not enabled, ignore\n");
        send_reply("403", "Forbidden");
        exit;
    }

    if ($dlg_var(recording) != 'yes') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: Start recording call\n");
        start_recording();
        $dlg_var(recording) = 'yes';

        if (is_method("REFER")) {
            send_reply("404", "Record On");
        } else {
            send_reply("200", "Record On");
        }
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: Stop recording call\n");
        stop_recording();
        $dlg_var(recording) = 'no';

        if (is_method("REFER")) {
            send_reply("404", "Record Off");
        } else {
            send_reply("200", "Record Off");
        }
    }

    exit;
}

# URI update for requests where alias found
route[RURIALIAS] {
    if(isdsturiset()) {
        return;
    }

    handle_ruri_alias();
    switch ($rc) {
    case -1:
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Failed to handle alias of R-URI $ru\n");
        send_reply("400", "Bad request");
        exit;
    case 1:
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Alias parsed, routing $rm from $fu to $du\n");
        break;
    case 2:
        # ;alias not found
        break;
    };

    return;
}

# Relay request
route[RELAY] {
    # Common for every transaction
    t_on_reply("MANAGE_REPLY");
    t_on_branch("MANAGE_BRANCH");

    # Only for non-initial transaction and for UAC initial (AS initial has custom route)
    if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");

    if (!t_relay())
        sl_reply_error();

    exit;
}

route[ANTIFLOOD] {
#!ifdef WITH_ANTIFLOOD
    # AS or myself
    if (src_ip==myself || ds_is_from_list("1")) return;

    # Trusted sources
    if (allow_trusted($si, 'any')) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (IP added in antiflood trusted IPs)\n");
        return;
    }

    # Allowed sources by company
    $var(group) = allow_source_address_group();
    if ($var(group) != -1) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: $si is not checked against antiflood (allowed source for companyId '$var(group)')\n");
        return;
    }

    # Evaluate PIKE
    if($sht(ipban=>$si) != $null) {
        # ip is already blocked
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
        exit;
    }
    if (!pike_check_req()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ANTIFLOOD: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
        $sht(ipban=>$si) = 1;
        exit;
    }
#!endif

    return;
}

# Handle SIP registrations
route[REGISTER] {
    if(!is_method("REGISTER")) return;

    if(isflagset(FLT_NATS)) {
        setbflag(FLB_NATB);
        # Enable SIP NAT pinging
        if ($proto == 'udp') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Enable UDP SIP OPTIONS pinging\n");
            setbflag(FLB_NATSIPPING);
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Enable TCP raw NAT keeper\n");
        }
    }

    # Store in kam_users_location_attrs used transport to retrieve it in lookup
    $xavp(ulattrs=>transport) = $proto;

    $var(contact_uri) = @contact.uri;
    save("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Something went wrong when saving location\n");
            sl_reply_error();
            break;
        case 1:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts inserted ($tu: $var(contact_uri))\n");
            break;
        case 2:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts updated ($tu: $var(contact_uri))\n");
            break;
        case 3:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts deleted ($tu: $var(contact_uri))\n");
            break;
        case 4:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts returned\n");
            break;
    };

    exit;
}

# Detect NAT
route[NATDETECT] {
    force_rport();

    if (nat_uac_test("18")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: NAT detected\n");
        setflag(FLT_NATS);

        if (is_method("REGISTER")) {
            fix_nated_register();
        } else if (is_method("SUBSCRIBE")) {
            fix_nated_contact();
        } else {
            if(is_first_hop()) {
                # Sets ;alias only if received ip and port differ from those in contact URI
                if (!add_contact_alias()) {
                   if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: Error in aliasing contact $ct\n");
                   send_reply("400", "Bad request");
                   exit;
                }
            }
        }
    }
}

route[WSFIX] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSFIX: Websockets detected, fix contact\n");
    # Do NAT traversal stuff for requests from a WebSocket
    # connection - even if it is not behind a NAT!
    # This won't be needed in the future if Kamailio and the
    # WebSocket client support Outbound and Path.
    force_rport();
    if (is_method("REGISTER")) {
        fix_nated_register();
    } else if (!add_contact_alias()) {
        if($dlg_var(nolog) != "1") xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSFIX: Error aliasing contact <$ct>\n");
        send_reply("400", "Bad Request");
        exit;
    }
    return;
}

# Handle NAT
route[NATMANAGE] {
    # RTP handling is always enforced
    route(RTPRELAY);

    # Set FLB_NATB? Only in within-dialog request with nat=yes on Route header initiated by AS
    if (is_request() && has_totag() && check_route_param("nat=yes") && ds_is_from_list("1")) {
       setbflag(FLB_NATB);
    }

    # Return unless FLT_NATS or FLB_NATB are set
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        return;
    }

    # Add nat=yes in record-route? Only in initial requests when called from branch_route
    if (is_request() && !has_totag() && t_is_branch_route()) {
        add_rr_param(";nat=yes");
    }

    # Add contact alias? Only to replies with NATB set and first hop
    if (is_reply() && isbflagset(FLB_NATB) && is_first_hop()) {
        # Sets ;alias only if received ip and port differ from those in contact URI
        if (!add_contact_alias()) {
           if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Error in aliasing contact $ct\n");
           send_reply("400", "Bad request");
           exit;
        }
    }
}

# Configure xlog
route[CONFIGURE_XLOG] {
    # Evaluate only once for SIP methods than can initiate transaction
    if ($dlg_var(log) == "0" || $dlg_var(log)) return;

    $dlg_var(log) = "0";

    if (is_method("INVITE") && $sel(cfg_get.dolog.invite)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REGISTER") && $sel(cfg_get.dolog.register)) {
        $dlg_var(log) = "1";
    }

    if (is_method("PUBLISH") && $sel(cfg_get.dolog.publish)) {
        $dlg_var(log) = "1";
    }

    if (is_method("SUBSCRIBE") && $sel(cfg_get.dolog.subscribe)) {
        $dlg_var(log) = "1";
    }

    if (is_method("NOTIFY") && $sel(cfg_get.dolog.notify)) {
        $dlg_var(log) = "1";
    }

    if (is_method("OPTIONS") && $sel(cfg_get.dolog.options)) {
        $dlg_var(log) = "1";
    }

    if (is_method("MESSAGE") && $sel(cfg_get.dolog.message)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REFER") && $sel(cfg_get.dolog.refer)) {
        $dlg_var(log) = "1";
    }

    # Needed variables
    if ($dlg_var(cidhash) == $null) {
        # Extract brandId (if present)
        if (is_present_hf('X-Info-BrandId')) {
            $dlg_var(brandId) = $hdr(X-Info-BrandId);
        } else if (lookup_domain("$fd")) {
            # If X-Info-BrandId not present, UAC talking
            # Guess brandId from domain :)
            $dlg_var(brandId) = $avp(brandId);
        }

        # Calculate callid hash
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});
        if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calculated hash for $rm $ci\n");
    }

    return;
}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    # Set proxy value
    $dlg_var(proxy) = 'USER';

    # Where is my caller? Order: PAI, RPID, From
    # Note: In UAC->AS, caller will be overriden with user extension
    if (is_present_hf("P-Asserted-Identity")) {
        $dlg_var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        $dlg_var(caller) = $(re{uri.user});
    } else {
        $dlg_var(caller) = $fU;
    }

    $dlg_var(callee) = $rU; # In AS->UAC, callee will be overriden with X-Info-Callee
    $dlg_var(callid) = $ci;
    if (is_present_hf("Diversion"))
        $dlg_var(diversion) = $(di{uri.user});

    if (is_present_hf("Referred-by")) {
        $dlg_var(referrer) = $(hdr(Referred-by){nameaddr.uri}{uri.user});
    }
}

# Reply generic route (all replies goes through this route)
onreply_route {
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ( $rm =~ $sel(cfg_get.dolog.printmsg_methods) ) xlog("L_WARN", "Received reply:\n\n$mb\n");
}

# Reply generic route (additional, for all replies)
onreply_route[MANAGE_REPLY] {
    # Control call limit if necessary
    if ($avp(AoR) != $null && !is_in_profile("callsPerAor", "$avp(AoR)")) {
        set_dlg_profile("callsPerAor", "$avp(AoR)");
        get_profile_size("callsPerAor", "$avp(AoR)", "$var(currentCalls)");
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_REPLY: '$avp(AoR)' has $var(currentCalls) calls now\n");
    }

    # Account user's missed calls if ringing
    if (is_method("INVITE") && t_check_status("180") && !ds_is_from_list("1")) {
        setflag(FLT_ACCMISSED);
    }

    # Manage NAT
    if (t_check_status("[12][0-9]{2}")) {
        route(NATMANAGE);
    }

    # Manage WS
    if (nat_uac_test(64)) { # 64 - Test if the source connection of signaling is WS
        # Do NAT traversal stuff for replies to a WebSocket connection
        # - even if it is not behind a NAT!
        # This won't be needed in the future if Kamailio and the
        # WebSocket client support Outbound and Path.
        add_contact_alias();
    }
}

failure_route[MANAGE_FAILURE] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(NATMANAGE);

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: t_is_canceled, exit here\n");
        exit;
    }
}

failure_route[MANAGE_FAILURE_AS] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    route(NATMANAGE);

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS '$avp(AVP_DST)' as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Route for branching: Only for INVITEs and BYEs (fork-able)
branch_route[MANAGE_BRANCH] {
    route(TRANSPORT_DETECT);
    route(NATMANAGE);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    if(isbflagset(FLB_WEBSOCKETS)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Answered dialog involves websockets\n");
        $dlg_var(ws) = 'yes';
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Dialog ended, delete keys from dialogs htable starting with $ci\n");
    sht_rm_name_re("dialogs=>$ci::.*");
}

onsend_route {
    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) {
        if (is_request())
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent request:\n\n$snd(buf)\n");
        else
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent reply:\n\n$snd(buf)\n");
    }

    if (is_method("ACK")) $dlg_var(confirmed) = '1';
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_WARN", "XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");
    route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[TRANSPORT_DETECT] {
    if (!is_method("INVITE")) return;

    if (is_request() && !has_totag()) {
        if ($rP == 'ws' || $rP == 'wss' || $proto == 'ws' || $proto == 'wss' || $xavp(ulattrs=>transport) == 'ws' || $xavp(ulattrs=>transport) == 'wss') {
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSPORT-DETECT: Websockets, set FLB_WEBSOCKETS\n");
            setbflag(FLB_WEBSOCKETS);
        }
    }
}

route[RTPRELAY] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;
    if (is_method("ACK") && !has_body("application/sdp")) return;

    if ($dlg_var(ws) == 'yes' || isbflagset(FLB_WEBSOCKETS)) {
        xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPRELAY: Websockets around, call rtpengine\n");
        route(RTPENGINE);
    } else {
        route(RTPPROXY);
    }
}

route[RTPPROXY] {
    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: Custom rtpproxy set: $dlg_var(mediaRelaySetsId)\n");
        set_rtp_proxy_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    if (nat_uac_test("18") && !ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: NAT detected, do not trust SDP addresses\n");
        rtpproxy_manage("cowf");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: No NAT detected, trust SDP addresses\n");
        rtpproxy_manage("coarf");
    }

    if (is_request() && is_method("INVITE") && !has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: Chosen RTPproxy instance $var(RTP_INSTANCE)\n");
    }
}

route[RTPENGINE] {
    $var(common_opts) = 'replace-session-connection replace-origin force';

    if (nat_uac_test("18") && !ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: NAT detected, do not trust SDP addresses\n");
        $var(symmetry) = 'symmetric SIP-source-address';
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: No NAT detected, trust SDP addresses\n");
        $var(symmetry) = 'asymmetric trust-address';
    }

    if ($proto == 'ws' || $proto == 'wss' ) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: Is through $proto, convert to udp\n");
        $var(wsopts) = 'ICE=remove RTP/AVP DTLS=no';
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: Is through $proto (non-ws), convert to wss\n");
        $var(wsopts) = 'ICE=force RTP/SAVPF DTLS=passive';
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: rtpengine_manage [$var(common_opts) $var(symmetry) $var(wsopts)]\n");
    rtpengine_manage("$var(common_opts) $var(symmetry) $var(wsopts)");
}

# Handle unsolicited NOTIFY messages (non-related to previous SUBSCRIBE)
route[NOTIFY] {
    if (!is_method("NOTIFY")) return;

    if (!ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NOTIFY: Received $rm from not AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # Lookup contact and relay
    route(LOOKUP);
    route(RELAY);
}

route[PRESENCE] {
    if(!is_method("PUBLISH|SUBSCRIBE")) return;

    if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
        send_reply("404", "No voicemail service");
        exit;
    }

    if (!t_newtran()) {
        sl_reply_error();
        exit;
    }

    if(is_method("PUBLISH")) {
        handle_publish();
        t_release();
    } else if(is_method("SUBSCRIBE")) {
        handle_subscribe();
        t_release();
    }
    exit;
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp == WS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "HTTP Request Received from $si:$sp\n");
    } else if ($Rp == WSS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "HTTPS Request Received from $si:$sp\n");
    } else {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "HTTP(S) request received on $Rp, port not allowed\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {
        # Validate Host - make sure the client is using the correct
        # alias for WebSockets
        # if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
        #     if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "Bad host $hdr(Host)\n");
        #     xhttp_reply("403", "Forbidden, bad host", "", "");
        #     exit;
        # }

        # Optional... validate Origin - make sure the client is from an
        # authorized website.  For example,
        #
        # if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
        #     && $hdr(Origin) != "https://communicator.MY_DOMAIN") {
        #       if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "Unauthorized client $hdr(Origin)\n");
        #       xhttp_reply("403", "Forbidden", "", "");
        #       exit;
        # }

        # Optional... perform HTTP authentication

        # ws_handle_handshake() exits (no further configuration file
        # processing of the request) when complete.
        if (ws_handle_handshake()) {
            # Optional... cache some information about the
            # successful connection
            if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "Connection upgrade to websocket was successful\n");
            exit;
        }
    }

    if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "HTTP(S) request received without Upgrade to Websocket header, 404\n");
    xhttp_reply("404", "Not found", "", "");
}

event_route[websocket:closed] {
    if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}

